{
  "category": "Band Filter",
  "content": "import pandas as pd\n\n\ndef calculate_window_size(\n    series: pd.Series, min_num_desired_datapoints: int, buffer_factor: float\n) -> float:\n    \"\"\"Window size calculation\n\n    Function to calculate the window size in seconds for the analysis of a timeseries\n    with moving windows.\n\n    series (Pandas Series): Series to calculate the window size for. The indices must be datetimes.\n    min_num_desired_datapoints (Integer): Minimum number of values supposed to be in each window.\n    buffer_factor (Float): Factor to multiply min_num_desired_datapoints with in order to allow\n        missing data within a window. Has to be a decimal percentage larger than 1.\n\n    Returns: Calculated window size in seconds.\n    \"\"\"\n    median_diff = series.sort_index().index.to_series().diff().median().seconds\n\n    return median_diff * (min_num_desired_datapoints * buffer_factor)\n\n\ndef create_pandas_frequency_string(value: float) -> str:\n    \"\"\"Conversion of a window size in seconds to a pandas frequency string\n\n    value (Float): Window size in seconds.\n\n    Returns: Pandas frequency string for the window size in seconds.\n    \"\"\"\n    return str(value) + \"S\"\n    \n\n# ***** DO NOT EDIT LINES BELOW *****\n# These lines may be overwritten if component details or inputs/outputs change.\nCOMPONENT_INFO = {\n    \"inputs\": {\n        \"series\": \"SERIES\",\n        \"min_num_desired_datapoints\": \"INT\",\n        \"buffer_factor\": \"FLOAT\",\n    },\n    \"outputs\": {\n        \"frequency_string\": \"STRING\",\n    },\n    \"name\": \"Infer Window Size\",\n    \"category\": \"Band Filter\",\n    \"description\": \"Infers the size to choose for a moving window\",\n    \"version_tag\": \"0.1.1\",\n    \"id\": \"8f97e59d-3817-466c-9235-3aed8ad32d7a\",\n    \"revision_group_id\": \"69da7fc6-7cbd-447b-a3c6-c72614a5fa7a\",\n    \"state\": \"RELEASED\",\n    \"released_timestamp\": \"2022-10-14T08:37:37.666911+00:00\",\n}\n\n\ndef main(*, series, min_num_desired_datapoints, buffer_factor):\n    # entrypoint function for this component\n    # ***** DO NOT EDIT LINES ABOVE *****\n    # write your function code here.\n\n    window_size = calculate_window_size(\n        series=series,\n        min_num_desired_datapoints=min_num_desired_datapoints,\n        buffer_factor=buffer_factor,\n    )\n\n    return {\"frequency_string\": create_pandas_frequency_string(window_size)}",
  "description": "Infers the size to choose for a moving window",
  "documentation": "# Infer Window Size\n\n## Description\nThis component calculates the window size for a given time series and creates a pandas frequency string for it.\n\n## Inputs\n* **series** (Pandas Series): Series to calculate the window size for. The indices must be datetimes.\n* **min_num_desired_datapoints** (Integer): Minimum number of values supposed to be in each window.\n* **buffer_factor** (Float): Factor to multiply *min_num_desired_datapoints* with in order to allow missing data within a window.\n\n## Outputs\n* **frequency_string** (String): The created pandas frequency string.\n\n## Details\nThis component calculates the window size for a given time series based on the median time difference between two consecutive data points in seconds. \n\nThe input **min_num_desired_datapoints** specifies the minimum number of values desired to be inside each window. A reasonable value is 30 to assume sampling normality.\n\nThe input **buffer_factor** is a decimal percentage that must be at least 1. It creates a buffer to perform the window calculation even if some data in missing. The value 1.1 means e.g. that 10 % of the values expected to be inside a window can be missing.\n\nThe calculated median is multiplied with these two inputs and converted into seconds to get the window size.\n\nThe result of the calculation is converted into a pandas frequency string to be able to use it as frequency input of pandas function, e.g. *pandas.DataFrame.rolling*. The string is always in seconds. The format works for both large and small time ranges even though metrics other than seconds might make more sense depending on the individual case.\n\n## Examples\nThe json input of a typical call of this component is\n```\n{\n\t\"series\": {\n\t\t\t\t\"2022-01-01T00:00:00Z\": 1.058,\n\t\t\t\t\"2022-01-01T00:20:48Z\": 0.699,\n\t\t\t\t\"2022-01-01T00:41:37Z\": 1.08,\n\t\t\t\t\"2022-01-01T01:02:26Z\": 1.054,\n\t\t\t\t\"2022-01-01T01:23:15Z\": 0.763,\n\t\t\t\t\"2022-01-01T01:44:04Z\": 1.034,\n\t\t\t\t\"2022-01-01T02:04:53Z\": 0.965,\n\t\t\t\t\"2022-01-01T02:25:42Z\": 0.601,\n\t\t\t\t\"2022-01-01T02:46:31Z\": 0.933,\n\t\t\t\t\"2022-01-01T03:07:20Z\": 1.081,\n\t\t\t\t\"2022-01-01T03:28:09Z\": 2.1,\n\t\t\t\t\"2022-01-01T03:48:58Z\": 0.988,\n\t\t\t\t\"2022-01-01T04:09:47Z\": 0.741,\n\t\t\t\t\"2022-01-01T04:30:36Z\": 0.647,\n\t\t\t\t\"2022-01-01T04:51:25Z\": 0.556,\n\t\t\t\t\"2022-01-01T05:12:14Z\": 0.453,\n\t\t\t\t\"2022-01-01T05:33:03Z\": 1.009,\n\t\t\t\t\"2022-01-01T05:53:52Z\": 1.72,\n\t\t\t\t\"2022-01-01T06:14:41Z\": 1.002,\n\t\t\t\t\"2022-01-01T06:56:19Z\": 0.857,\n\t\t\t\t\"2022-01-01T07:17:08Z\": 0.864,\n\t\t\t\t\"2022-01-01T07:37:57Z\": 0.606,\n\t\t\t\t\"2022-01-01T07:58:46Z\": 0.899,\n\t\t\t\t\"2022-01-01T08:40:24Z\": 0.62,\n\t\t\t\t\"2022-01-01T10:03:40Z\": 0.721,\n\t\t\t\t\"2022-01-01T10:24:29Z\": 1.193,\n\t\t\t\t\"2022-01-01T10:45:18Z\": 0.833,\n\t\t\t\t\"2022-01-01T11:06:07Z\": 2.06,\n\t\t\t\t\"2022-01-01T11:26:56Z\": 0.68,\n\t\t\t\t\"2022-01-01T11:47:45Z\": 1.136,\n\t\t\t\t\"2022-01-01T12:08:34Z\": 0.62,\n\t\t\t\t\"2022-01-01T12:29:23Z\": 0.946,\n\t\t\t\t\"2022-01-01T12:50:12Z\": 0.746,\n\t\t\t\t\"2022-01-01T13:11:01Z\": 0.833,\n\t\t\t\t\"2022-01-01T13:31:50Z\": 0.857,\n\t\t\t\t\"2022-01-01T14:13:28Z\": 0.947,\n\t\t\t\t\"2022-01-01T14:34:17Z\": 0.841,\n\t\t\t\t\"2022-01-01T14:55:06Z\": 0.668,\n\t\t\t\t\"2022-01-01T15:15:55Z\": 0.675,\n\t\t\t\t\"2022-01-01T15:36:44Z\": 0.84,\n\t\t\t\t\"2022-01-01T15:57:33Z\": 0.821,\n\t\t\t\t\"2022-01-01T16:18:22Z\": 0.625,\n\t\t\t\t\"2022-01-01T16:39:11Z\": 1.155,\n\t\t\t\t\"2022-01-01T17:00:00Z\": 0.968\n\t},\n\t\"min_num_desired_datapoints\": 10,\n\t\"buffer_factor\": 1.4\n}\n```\nThe expected output is\n```\n\t\"frequency_string\": \"17486.0S\"\n```\n",
  "id": "8f97e59d-3817-466c-9235-3aed8ad32d7a",
  "io_interface": {
    "inputs": [
      {
        "data_type": "SERIES",
        "id": "4e52ceed-ba2f-4b82-b971-0397810b6c41",
        "name": "series"
      },
      {
        "data_type": "INT",
        "id": "9e38887c-f13c-4d95-85ce-b9b6a0cec59d",
        "name": "min_num_desired_datapoints"
      },
      {
        "data_type": "FLOAT",
        "id": "9e978f37-7292-4811-9f5c-b0bbeed87047",
        "name": "buffer_factor"
      }
    ],
    "outputs": [
      {
        "data_type": "STRING",
        "id": "744696b8-360b-4429-b9fb-2b8e663bc02b",
        "name": "frequency_string"
      }
    ]
  },
  "name": "Infer Window Size",
  "released_timestamp": "2022-10-14T08:37:37.666911+00:00",
  "revision_group_id": "69da7fc6-7cbd-447b-a3c6-c72614a5fa7a",
  "state": "RELEASED",
  "test_wiring": {
    "input_wirings": [
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "{\"2022-01-01T00:00:00Z\": 1.058,\n \"2022-01-01T00:20:48Z\": 0.699,\n \"2022-01-01T00:41:37Z\": 1.08,\n \"2022-01-01T01:02:26Z\": 1.054,\n \"2022-01-01T01:23:15Z\": 0.763,\n \"2022-01-01T01:44:04Z\": 1.034,\n \"2022-01-01T02:04:53Z\": 0.965,\n \"2022-01-01T02:25:42Z\": 0.601,\n \"2022-01-01T02:46:31Z\": 0.933,\n \"2022-01-01T03:07:20Z\": 1.081,\n \"2022-01-01T03:28:09Z\": 2.1,\n \"2022-01-01T03:48:58Z\": 0.988,\n \"2022-01-01T04:09:47Z\": 0.741,\n \"2022-01-01T04:30:36Z\": 0.647,\n \"2022-01-01T04:51:25Z\": 0.556,\n \"2022-01-01T05:12:14Z\": 0.453,\n \"2022-01-01T05:33:03Z\": 1.009,\n \"2022-01-01T05:53:52Z\": 1.72,\n \"2022-01-01T06:14:41Z\": 1.002,\n \"2022-01-01T06:56:19Z\": 0.857,\n \"2022-01-01T07:17:08Z\": 0.864,\n \"2022-01-01T07:37:57Z\": 0.606,\n \"2022-01-01T07:58:46Z\": 0.899,\n \"2022-01-01T08:40:24Z\": 0.62,\n \"2022-01-01T10:03:40Z\": 0.721,\n \"2022-01-01T10:24:29Z\": 1.193,\n \"2022-01-01T10:45:18Z\": 0.833,\n \"2022-01-01T11:06:07Z\": 2.06,\n \"2022-01-01T11:26:56Z\": 0.68,\n \"2022-01-01T11:47:45Z\": 1.136,\n \"2022-01-01T12:08:34Z\": 0.62,\n \"2022-01-01T12:29:23Z\": 0.946,\n \"2022-01-01T12:50:12Z\": 0.746,\n \"2022-01-01T13:11:01Z\": 0.833,\n \"2022-01-01T13:31:50Z\": 0.857,\n \"2022-01-01T14:13:28Z\": 0.947,\n \"2022-01-01T14:34:17Z\": 0.841,\n \"2022-01-01T14:55:06Z\": 0.668,\n \"2022-01-01T15:15:55Z\": 0.675,\n \"2022-01-01T15:36:44Z\": 0.84,\n \"2022-01-01T15:57:33Z\": 0.821,\n \"2022-01-01T16:18:22Z\": 0.625,\n \"2022-01-01T16:39:11Z\": 1.155,\n \"2022-01-01T17:00:00Z\": 0.968}"
        },
        "workflow_input_name": "series"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "10"
        },
        "workflow_input_name": "min_num_desired_datapoints"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "1.4"
        },
        "workflow_input_name": "buffer_factor"
      }
    ],
    "output_wirings": []
  },
  "type": "COMPONENT",
  "version_tag": "0.1.1"
}